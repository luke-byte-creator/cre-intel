/**
 * Colliers Scraper for Nova CRE Intelligence Platform
 * Scrapes Colliers Canada listings for office, industrial, multi-family properties in Saskatoon
 * Source: https://www.collierscanada.com/listings (filtered to Saskatoon)
 * Note: Behind Cloudflare protection - requires Playwright browser
 */

import { Page } from 'playwright';
import { 
  browserPool, 
  rateLimiter, 
  withRetry, 
  createScrapingPage, 
  cleanText, 
  parseSquareFeet, 
  parsePrice,
  classifyPropertyType,
  shouldScrapePropertyType
} from './utils';

export interface ColliersListing {
  address: string;
  property_type: string;
  listing_type: string; // 'sale' or 'lease'
  asking_price: number | null;
  asking_rent: number | null;
  square_feet: number | null;
  description: string | null;
  broker: string | null;
  brokerage_firm: string;
  source_url: string;
  listing_id: string | null;
  raw_data: string;
}

export interface ColliersScrapingResult {
  listings: ColliersListing[];
  metadata: {
    totalFound: number;
    totalProcessed: number;
    filteredOut: number;
    cloudflareEncountered: boolean;
  };
}

export class ColliersScraper {
  private baseUrl = 'https://www.collierscanada.com';
  private searchUrl = 'https://www.collierscanada.com/listings';
  private brokerageFirm = 'Colliers';

  async scrape(): Promise<ColliersScrapingResult> {
    console.log('Starting Colliers scraper...');
    
    const browser = await browserPool.getBrowser();
    const page = await createScrapingPage(browser);
    
    // Configure page to handle Cloudflare
    await this.configureForCloudflare(page);
    
    try {
      const result = await withRetry(() => this.scrapeListings(page), 5, 2000);
      return result;
    } finally {
      await page.close();
    }
  }

  private async configureForCloudflare(page: Page): Promise<void> {
    // Set additional headers and behavior to avoid Cloudflare detection
    await page.setExtraHTTPHeaders({
      'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7',
      'Accept-Language': 'en-US,en;q=0.9',
      'Cache-Control': 'max-age=0',
      'Sec-Ch-Ua': '"Not_A Brand";v="8", "Chromium";v="120", "Google Chrome";v="120"',
      'Sec-Ch-Ua-Mobile': '?0',
      'Sec-Ch-Ua-Platform': '"macOS"',
      'Sec-Fetch-Dest': 'document',
      'Sec-Fetch-Mode': 'navigate',
      'Sec-Fetch-Site': 'none',
      'Sec-Fetch-User': '?1',
      'Upgrade-Insecure-Requests': '1',
    });

    // Additional stealth settings
    await page.addInitScript(() => {
      Object.defineProperty(navigator, 'webdriver', {
        get: () => undefined,
      });
    });
  }

  private async scrapeListings(page: Page): Promise<ColliersScrapingResult> {
    await rateLimiter.wait();
    
    console.log('Navigating to Colliers listings page...');
    let cloudflareEncountered = false;
    
    try {
      await page.goto(this.searchUrl, { waitUntil: 'networkidle', timeout: 30000 });
      
      // Check for Cloudflare challenge
      const cloudflareCheck = await page.$('.cf-error-title, #cf-spinner, .cf-browser-verification');
      if (cloudflareCheck) {
        console.log('Cloudflare challenge detected, waiting...');
        cloudflareEncountered = true;
        await page.waitForSelector('body', { timeout: 15000 });
        await page.waitForTimeout(5000); // Additional wait for challenge completion
      }
      
    } catch (error) {
      console.warn('Error loading Colliers page, may be blocked:', error);
      return {
        listings: [],
        metadata: {
          totalFound: 0,
          totalProcessed: 0,
          filteredOut: 0,
          cloudflareEncountered: true,
        },
      };
    }
    
    // Set up search filters
    await this.setupSearchFilters(page);
    
    const allListings: ColliersListing[] = [];
    let pageNum = 1;
    let filteredOut = 0;
    
    while (true) {
      console.log(`Scraping Colliers page ${pageNum}...`);
      
      try {
        // Wait for listings to load with multiple possible selectors
        await page.waitForSelector('.listing-item, .property-item, .search-result, .listing-card', { timeout: 20000 });
      } catch (error) {
        console.warn(`No listings found on page ${pageNum}, stopping`);
        break;
      }
      
      const pageListings = await this.extractListingsFromPage(page);
      
      // Filter for relevant property types and Saskatoon location
      const relevantListings = pageListings.filter(listing => {
        const isSaskatoon = listing.address.toLowerCase().includes('saskatoon') || 
                           listing.address.toLowerCase().includes('sk');
        const isRelevantType = shouldScrapePropertyType(listing.propertyType);
        
        if (isSaskatoon && isRelevantType) {
          return true;
        } else {
          filteredOut++;
          return false;
        }
      });
      
      allListings.push(...relevantListings);
      console.log(`Colliers page ${pageNum}: ${pageListings.length} listings found, ${relevantListings.length} relevant`);
      
      // Check for next page
      const nextPageButton = await page.$('button[aria-label*="Next"], .pagination .next, .next-page, [data-testid*="next"]');
      if (!nextPageButton || !(await nextPageButton.isEnabled())) {
        break;
      }
      
      await rateLimiter.wait();
      await nextPageButton.click();
      await page.waitForLoadState('networkidle');
      pageNum++;
      
      // Safety limit
      if (pageNum > 25) {
        console.warn('Reached page limit (25), stopping');
        break;
      }
    }
    
    console.log(`Colliers scraping complete: ${allListings.length} relevant listings from ${pageNum} pages`);
    
    return {
      listings: allListings,
      metadata: {
        totalFound: allListings.length + filteredOut,
        totalProcessed: allListings.length,
        filteredOut,
        cloudflareEncountered,
      },
    };
  }

  private async setupSearchFilters(page: Page): Promise<void> {
    try {
      console.log('Setting up Colliers search filters...');
      
      // Look for and fill location search
      const locationSelectors = [
        'input[placeholder*="location"]',
        'input[placeholder*="city"]',
        'input[name*="location"]',
        'input[id*="location"]',
        '.location-input input',
        '.search-location input'
      ];
      
      for (const selector of locationSelectors) {
        const locationInput = await page.$(selector);
        if (locationInput) {
          await locationInput.fill('Saskatoon, Saskatchewan');
          await page.keyboard.press('Tab');
          await page.waitForTimeout(1000);
          break;
        }
      }
      
      // Select property types
      const propertyTypes = ['Office', 'Industrial', 'Multi-Family', 'Multifamily'];
      
      for (const propType of propertyTypes) {
        const typeSelectors = [
          `input[value*="${propType}"]`,
          `label:has-text("${propType}") input`,
          `button:has-text("${propType}")`,
          `[data-value*="${propType.toLowerCase()}"]`
        ];
        
        for (const selector of typeSelectors) {
          try {
            const element = await page.$(selector);
            if (element) {
              await element.click();
              await page.waitForTimeout(500);
              break;
            }
          } catch (e) {
            // Continue if selector doesn't work
          }
        }
      }
      
      // Submit search if there's a search button
      const searchButtons = [
        'button[type="submit"]',
        '.search-button',
        'button:has-text("Search")',
        '[data-testid*="search"]'
      ];
      
      for (const selector of searchButtons) {
        const searchButton = await page.$(selector);
        if (searchButton) {
          await searchButton.click();
          await page.waitForLoadState('networkidle');
          break;
        }
      }
      
    } catch (error) {
      console.warn('Error setting up Colliers search filters:', error);
      // Continue anyway
    }
  }

  private async extractListingsFromPage(page: Page): Promise<ColliersListing[]> {
    const listings: ColliersListing[] = [];
    
    // Try various selectors for Colliers listing containers
    const listingSelectors = [
      '.listing-item',
      '.property-item',
      '.search-result',
      '.listing-card',
      '.property-card',
      '.result-card',
      '[data-testid*="listing"]',
      '[data-testid*="property"]'
    ];
    
    let listingElements: any[] = [];
    
    for (const selector of listingSelectors) {
      listingElements = await page.$$(selector);
      if (listingElements.length > 0) {
        console.log(`Found ${listingElements.length} Colliers listings using selector: ${selector}`);
        break;
      }
    }
    
    if (listingElements.length === 0) {
      console.warn('No Colliers listing elements found on page');
      return listings;
    }
    
    for (const element of listingElements) {
      try {
        const listing = await this.extractListingFromElement(page, element);
        if (listing) {
          listings.push(listing);
        }
      } catch (error) {
        console.warn('Error extracting Colliers listing:', error);
        continue;
      }
    }
    
    return listings;
  }

  private async extractListingFromElement(page: Page, element: any): Promise<ColliersListing | null> {
    try {
      const listingText = await element.textContent() || '';
      const listingHtml = await element.innerHTML() || '';
      
      // Extract URL
      let sourceUrl = this.searchUrl;
      const linkElement = await element.$('a');
      if (linkElement) {
        const href = await linkElement.getAttribute('href');
        if (href) {
          sourceUrl = href.startsWith('http') ? href : `${this.baseUrl}${href}`;
        }
      }
      
      // Extract listing ID
      const listingIdMatch = sourceUrl.match(/\/property\/([^\/\?]+)|\/listing\/([^\/\?]+)|id[=:]([^&\s]+)/i);
      const listingId = listingIdMatch ? (listingIdMatch[1] || listingIdMatch[2] || listingIdMatch[3]) : null;
      
      // Extract address
      let address = '';
      
      // Try structured elements first
      const addressSelectors = [
        '.address',
        '.location', 
        '.property-address',
        '[class*="address"]',
        '[data-testid*="address"]',
        '.listing-location'
      ];
      
      for (const selector of addressSelectors) {
        const addressElement = await element.$(selector);
        if (addressElement) {
          address = cleanText(await addressElement.textContent() || '');
          if (address) break;
        }
      }
      
      // Fallback to text patterns
      if (!address) {
        const addressPatterns = [
          /(\d+[\s\-]+[\w\s]+(ST|AVE|DR|RD|BLVD|CRES|PL|WAY|LANE|CRT|TERR|PKWY|HWY)[\w\s]*,?\s*Saskatoon)/im,
          /(\d+[\s\-]+[\w\s]+(ST|AVE|DR|RD|BLVD|CRES|PL|WAY|LANE|CRT|TERR|PKWY|HWY)[\w\s]*)/im,
        ];
        
        for (const pattern of addressPatterns) {
          const match = listingText.match(pattern);
          if (match) {
            address = cleanText(match[1]);
            break;
          }
        }
      }
      
      if (!address) {
        console.warn('No address found for Colliers listing, skipping');
        return null;
      }
      
      // Classify property type
      const propertyType = classifyPropertyType(listingText + ' ' + listingHtml);
      
      // Determine listing type
      const listingType = this.determineListingType(listingText + ' ' + listingHtml);
      
      // Extract price/rent
      let askingPrice: number | null = null;
      let askingRent: number | null = null;
      
      if (listingType === 'sale') {
        askingPrice = parsePrice(listingText);
      } else {
        askingRent = this.parseRent(listingText);
      }
      
      // Extract square footage
      const squareFeet = parseSquareFeet(listingText);
      
      // Extract broker name
      let broker: string | null = null;
      const brokerSelectors = [
        '.broker', 
        '.agent', 
        '.contact',
        '[class*="broker"]',
        '[data-testid*="agent"]',
        '.listing-agent'
      ];
      
      for (const selector of brokerSelectors) {
        const brokerElement = await element.$(selector);
        if (brokerElement) {
          broker = cleanText(await brokerElement.textContent() || '');
          if (broker) break;
        }
      }
      
      // Extract description
      let description: string | null = null;
      const descSelectors = [
        '.description',
        '.details', 
        '.property-details',
        '[class*="desc"]',
        '.listing-description'
      ];
      
      for (const selector of descSelectors) {
        const descElement = await element.$(selector);
        if (descElement) {
          description = cleanText(await descElement.textContent() || '');
          if (description) break;
        }
      }
      
      if (!description) {
        description = cleanText(listingText).substring(0, 500);
      }
      
      if (!propertyType) {
        console.warn(`Could not determine property type for Colliers listing: ${address}`);
        return null;
      }
      
      return {
        address,
        propertyType,
        listingType,
        askingPrice,
        askingRent,
        squareFeet,
        description,
        broker,
        brokerageFirm: this.brokerageFirm,
        sourceUrl,
        listingId,
      };
      
    } catch (error) {
      console.warn('Error extracting Colliers listing details:', error);
      return null;
    }
  }

  private determineListingType(text: string): string {
    const lowerText = text.toLowerCase();
    
    // Look for sale indicators
    if (lowerText.includes('for sale') || lowerText.includes('purchase') || 
        lowerText.includes('investment') && lowerText.includes('cap rate') ||
        lowerText.includes('acquisition')) {
      return 'sale';
    }
    
    // Look for lease indicators  
    if (lowerText.includes('for lease') || lowerText.includes('rent') || 
        lowerText.includes('leasing') || lowerText.includes('$/sf') || 
        lowerText.includes('per sq ft')) {
      return 'lease';
    }
    
    // Default to lease
    return 'lease';
  }

  private parseRent(text: string): number | null {
    const rentPatterns = [
      /\$(\d{1,3}(?:,\d{3})*(?:\.\d{2})?)\s*\/?\s*(?:sq\.?\s*ft\.?|sf)\s*\/?\s*(?:month|mo|annually|year|yr)?/i,
      /\$(\d{1,3}(?:,\d{3})*(?:\.\d{2})?)\s*(?:per\s+)?(?:sq\.?\s*ft\.?|sf)/i,
      /\$(\d{1,3}(?:,\d{3})*(?:\.\d{2})?)\s*(?:\/month|\/mo|\/year|\/yr|monthly|annually)/i,
    ];
    
    for (const pattern of rentPatterns) {
      const match = text.match(pattern);
      if (match) {
        return parseFloat(match[1].replace(/,/g, ''));
      }
    }
    
    return null;
  }
}

// Export singleton instance
export const colliersScraper = new ColliersScraper();